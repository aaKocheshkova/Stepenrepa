#include <iostream>
#include <cmath>
#include <iomanip>
#include "D:\visual\stepen\stepenLib\h_stand_fun.h"
#include "D:\visual\stepen\stepenLib\h_step_fun.h"

using namespace std;
void main()
{
	//русификация
	setlocale(LC_ALL, "rus");
	//объявление переменных
	double ks, bs, G, H, J, K, L, sl, M, sm, smk;
	int n;
	double *x, *y;
	//ввод размера вектора и самих векторов
	cout << "\nВведите количество координат n\n";
	cin >> n;
	x = new double[n];
	y = new double[n];
	cout << "\nВведите первый вектор\n";
	inputv(x, n);
	cout << "\nВведите второй вектор\n";
	inputv(y, n);
	//вывод вектора
	cout << "\nПервый вектор:\n";
	outputv(x, n);
	cout << "\nВторой вектор:\n";
	outputv(y, n);
	cout << "\nВЫЧИСЛЕНИЯ ДЛЯ СТЕПЕННОЙ АППРОКСИМАЦИИ\n";
	//вычисление суммы координат для степенной аппроксимации
	H = SumaLN(x, n);
	J = SumaLN(y, n);
	//вычисление скалярного произведения векторов для степенной аппроксимации
	G = ProizLN(x, y, n);
	//сумма квадратов координат для степенной аппроксимации
	K = SumKvadLN(x, n);
	cout << "\nСумма координат первого вектора = " << H;
	cout << "\nСумма координат второго вектора = " << J;
	cout << "\nСкалярное произведение векторов для степенной аппроксимации = " << G;
	cout << "\nСумма квадратов координат первого вектора для степенной аппроксимации = " << K;
	cout.setf(ios::fixed);
	cout.precision(8);
	//считаем коэффициенты для степенной аппроксимации
	bs = (n*G - H*J) / (n*K - pow(H, 2));
	ks = exp((J - bs*H) / n);
	cout << "\nКоэффициент b для степенной аппроксимации = " << bs;
	cout << "\nКоэффициент k для степенной аппроксимации = " << ks << endl;
	cout << "\nТогда уравнение будет иметь вид" << endl;
	cout << "\ny = " << ks << "*x^" << bs << endl;
	double Rs = 0;
	//считаем числитель для суммарной квадратичной погрешности степенной аппроксимации
	sl = 0;
	sm = 0;
	smk = 0;
	for (int i = 0; i < n; i++)
	{
		L = y[i] - (ks*pow(x[i], bs));
		sl = sl + pow(L, 2);
	}
	//считаем слагаемые знаменателя для суммарной квадратичной погрешности степенной аппроксимации
	for (int i = 0; i < n; i++)
	{
		M = ks*pow(x[i], bs);
		sm = sm + pow(M, 2);
		smk = smk + M;
	}
	smk = pow(smk, 2);
	//считаем суммарную квадратичную погрешность для степенной аппроксимации
	Rs = 1 - (sl / (sm - smk / n));
	//выводим результаты
	cout << "\nСуммарная квадратичная погрешность для степенной аппроксимации R = " << Rs;
	cout.unsetf(ios::fixed);
	cout << endl;
}